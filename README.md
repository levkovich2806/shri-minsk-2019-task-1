# shri-minsk-2019-task-1

<h1 align="center">Домашняя работа - Адаптивная верстка</h1>
<h2 align="center">Выполнил - Левкович Сергей</h2>

1. Сборка проекта - npm install + npm run build
2. Собранные файлы проекта будут расоложены в папке dist

<h3>Что в проекте:</h3>
<p>- React НЕ использовался;</p>
<p>- с помощью webpack производится сборка проекта по установленным правилам в файле webpack.config.js, в частности: транспилятор кода (babel), сборщик scss (перевод в css и его минификация), сборщик изображений и шрифтов;</p>
<p>- перед каждой сборкой, спомощью плагина clean-webpack-plugin производится полная очистка папки dist;</p>
<p>- добавлен StyleLint (в частности в git hook (pre-commit)с использованием husky);</p>
<p>- добавлен ESLint.</p>

<h3>Почему я использовал те или иные вещи:</h3>
<p>1. SCSS - работаю с ним уже несколько месяцев и доволен выбором - переменные, возможность использовать вложенности (вида &__), математические операторы и т.п.;</p>
<p>2. Для парсинга json написал <b>собственный парсер</b>, что бы полностью контролировать этот процесс (src/js/parser.js) - суть парсера (думаю, как и у любого другого) состоит в том, что бы пройтись последовательно по всем элементам массива заметок и, исходя из конкретных условий, "подготовить" HTML код отдельной заметки - затем все они добавляются в один "контейнер";</p>
<p></p>

<h3>На что можно обратить внимание по верстке:</h3>
<p>1. Добавлено отображение элементов "подтвердить" и "редактировать" по "ховеру" на заметку.</p>
<p>2. Добавлено отображение границы заметки по "ховеру" на заметку.</p>
<p>3. Добавлена "подсветка" цветных блоков в "шапке" заметок</p>
<p>4. Добавлены hover и active на кнопки Найти и Добавить</p>
<p>5. Постарался сделать, что бы при изменениях размеров экрана заметки меняли свое положение почаще, что бы не было совсем единобразно</p>
<p>6. На картинки "под заметками" добавил ссылки на открытие полной картинки</p>
<p>7. При малых размерах экрана (мобильники) появляется возможность "прокручивать" список "цветов" заметок
<p>8. По клику по заметке не делал вызов модального окна - модальное окно буду вызывать позже при клике на "Добавить" - прошу не снимать за это баллы в 1 домашнем задании.</p>
<p>... Все смены стилей по hover или active производятся с transition</p>


<h1>Node.js</h1>
<h3>Запуск - npm start (клиент и сервер одновременно)</h3>
<p>Сервер написан на express, поднимается на 8000 порту</p>
<p>Для получения коллекции заметок реализован GET /api/cards</p>
<p>Для добавления заметки релизован POST /api/cards.</p>
<p>Для удалениея заметки реализован DELETE /api/cards/:id</p>
<p>Для модификации заметки реализован PATCH /api/cards/:id</p>
<p>Для получения заметок отправленных в архив реализован /api/cards/archive</p>
<p>Реализована возможность получать отфильтрованный список заметок в зависимости от переданного id цвета заметки, на пример, /api/cards?color=1. Если передан цвет не содержащийся в коллекции цветов - сервер отвечает "Incorrect color" со статусом 400</p>
<p>Все роуты, не описанные на сервере отдают Page not found (с тэгом h1) со статусом 404</p>
<p>Так же в файле server/utils/utils.js созданы вспомогательные функции, в частности:</p>
  <ul>
  <li>getColorsHash() - создаем хэш коллекции цветов для доступа к нужному цвету по id без постоянного мапинга массива</li>
  <li>getCardSequence() - увеличиваем счетчик id заметок (если бы была реализована БД, то это помогло бы нам избежать дубликатов ID (работает быстрее, чем поиск ID последнего добавленного жлемента))</li>
  <li>getCardSize() - функция, которая по придуманному мною во 2 домашнем задании алгоритму вовзращает размер заметки, если он не был передан с клиента при добавлении новой заметки</li>
  <li> и др. - их назначение описаны в файле
  </ul>
<hr>
<p>На стороне клиента реализованы функции, с помощью которых происходит обращение к серверу за нужной информацией (или передача информации на сервер) - src/service/main.js - запрос заметок, добавление заметки, модицикация заметки, удаление заметки, изменение статуса заметки ( archive (status = 0) или inUse (status = 1) )</p>
<p>Так же в отдельно созданном файле utils/request.js подготовлена асинхронная функция sendRequest. Для взимодействия с сервером используется fetch - выбран из-за того, что возвращает Promise,что бы можно было корректно обрабатывать любой вид ошибки или корректный ответа сервера. Так же много с ним работал и зарекомендовал себя только с положительной стороны</p>

<h1>Что дальше?</h1>
<p>Так как 3 домашняя работа не предусматривала привязку всех запросов к сайту, в дальнейшем приложение будет переведено на React с последующим подключением всех API к элементам системы</p>
